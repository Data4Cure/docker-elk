input {
	tcp {
		port => 5044
		codec => json
#		ssl_enable => true
#		ssl_cert => "/etc/pki/tls/certs/logstash-forwarder.crt"
#		ssl_key => "/etc/pki/tls/private/logstash-forwarder.key"
	}
	beats {
		port => 15044
	}
}

filter {
  if [type] == "syslog" {
    grok {
      match => { "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:message}" }
      add_field => [ "received_at", "%{@timestamp}" ]
      add_field => [ "received_from", "%{host}" ]
    }
    syslog_pri { }
    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
    }
    overwrite => [ "message" ]
#    grok {
#      match => { "message" => "Accepted %{USER:user}
#    }
  }
#    geoip {
#      source => "[ip]"
#      target => "geoip"
#      database => "/etc/logstash/GeoLiteCity.dat"
#      add_field => [ "[geoip][coordinates]", "%{[geoip][longitude]}" ]
#      add_field => [ "[geoip][coordinates]", "%{[geoip][latitude]}"  ]
#    }
#    mutate {
#      convert => [ "[geoip][coordinates]", "float"]
#    }
#    geoip {
#      source => "real_ip"
#      target => "real_geoip"
#      database => "/etc/logstash/GeoLiteCity.dat"
#      add_field => [ "[real_geoip][coordinates]", "%{[real_geoip][longitude]}" ]
#      add_field => [ "[real_geoip][coordinates]", "%{[real_geoip][latitude]}"  ]
#    }
#    mutate {
#      convert => [ "[real_geoip][coordinates]", "float"]
#    }
}

output {
	elasticsearch {
		hosts => "elasticsearch:9200"
	}
}
